package lessons.lesson10_materials;

import lessons.lesson10_materials.BattleBoard;

public class Monster {

	public static int numOfMonsters = 0;
	
	public final String TOMBSTONE = "Here lies a dead monster";
	
	private int health = 500;
	private int attack = 20;
	private int movement = 2;
	public int xPosition = 0;
	public int yPosition = 0;
	
	private boolean alive = true;
	
	public String name = "Big Monster";
	public char nameChar = 'B';
	
	public int getAttack() {  
		return attack; 
	}

	public int getMovement() {
		return movement;
	}
	
	public int getHealth() {
		return health;
	}
	
	public void setHealth(int decreaseHealth) {
		health = health - decreaseHealth;
		
		if (health < 0) {
			health = 0;
			alive = false;
		}
	}
	
	public boolean getAlive() {
		return alive;
	}
	
	/* Overloading: Same method but with different arguments. 
	 * Depending on which values are passed as arguments, the correct
	 * method implementation will be used.
	 * Careful: all definitions in the method except parameters have to be the same
	 * (i.e. name, return-type etc.)
	 * */
	public void setHealth(double decreaseHealth) {
		int decrease = (int) decreaseHealth;
		health = health - decrease;
		
		if (health < 0) {
			alive = false;
		}
	}
	
	public void moveMonster(Monster[] Monsters, int arrayItemIndex) {
		boolean isSpaceOpen = true;
		
		int maxXBoardSpace = BattleBoard.battleBoard.length - 1;
		int maxYBoardSpace = BattleBoard.battleBoard[0].length - 1;
		
		while(isSpaceOpen) {
			int randMoveDirection = (int) (Math.random() * 4);
			int randMoveDistance = (int) (Math.random() * (this.movement));
			System.out.println(randMoveDistance + " " + randMoveDirection);
			
			BattleBoard.battleBoard[this.yPosition][this.xPosition] = '*';
			
			// ---- Protect Monster from going beyond the board ----
			// 0 = North
			if(randMoveDirection == 0) {
				if ((this.yPosition - randMoveDistance) < 0) {
					this.yPosition = 0;
				
				} else {
					this.yPosition = this.yPosition - randMoveDistance;
				
				}

			// 1 = East
			} else if (randMoveDirection == 1) {
				if ((this.xPosition + randMoveDistance) > maxXBoardSpace) {
					this.xPosition = maxXBoardSpace;
				
				} else {
					this.xPosition = this.xPosition + randMoveDistance;
				
				}
				
			// 2 = South
			} else if (randMoveDirection == 2) {
				if ((this.yPosition + randMoveDistance) > maxYBoardSpace) {
					this.yPosition = maxYBoardSpace;
				
				} else {
					this.yPosition = this.yPosition + randMoveDistance;
				
				}
				
			// 3 = West
			} else if (randMoveDirection == 3) {
				if ((this.xPosition - randMoveDistance) < 0) {
					this.xPosition = 0;
				
				} else {
					this.xPosition = this.xPosition - randMoveDistance;
				
				}
			}
		
			for (int i = 0; i < Monsters.length; i++) {
				
				// If i hits the current monster being moved
				if ( i == arrayItemIndex) {
					// continue -> avoid checking monster against itself
					continue;
				}
				
				if ( onMySpace(Monsters, i, arrayItemIndex)) {
					isSpaceOpen = true;
					
				} else {
					isSpaceOpen = false;
					
				}
			}
		} // End of while loop
		
		// save monster at new position by saving the nameChar
		BattleBoard.battleBoard[this.yPosition][this.xPosition] = this.nameChar;
		
	} // End of moveMonster
	
	private boolean onMySpace(Monster[] Monsters, int indexToCheck, int currentMosnterIndex) {
		// Check if both monsters have the same X, Y-Position
		if ((Monsters[indexToCheck].xPosition) == (Monsters[currentMosnterIndex].xPosition) && 
				(Monsters[indexToCheck].yPosition) == (Monsters[currentMosnterIndex].yPosition)) {
			return true;
		} else {
			return false;
		}
	}
	
	// Constructor. No return-type but same name as class
	public Monster(int newHealth, int newAttack, int newMovement, String name) {
		// this -> refers to class instance!
		this.health = newHealth;
		this.attack = newAttack;
		this.movement = newMovement;
		this.name = name;

		int randNumX, randNumY;
		
		do {
			
			randNumX = (int) (Math.random() * BattleBoard.getMaxXBoardSpace());
			randNumY = (int) (Math.random() * BattleBoard.getMaxYBoardSpace());
			
		} while (BattleBoard.battleBoard[randNumX][randNumY] != '*');
		
		this.xPosition = randNumX;
		this.yPosition = randNumY;
		
		this.nameChar = name.charAt(0);
		
		BattleBoard.battleBoard[this.yPosition][this.xPosition] = this.nameChar;
		numOfMonsters++;
	}
	
	/* This is the default constructor. It sets no attributes etc.
	 * If any constructor is defined - this default constructor will not
	 * be automatically generated by Java.
	 */
	public Monster() {
		numOfMonsters++;
	}
	
	public Monster(int newHealth) {
		this.health = newHealth;
	}
	
	public Monster(int newHealth, int newAttack) {
		// this calls the appropriate constructor which takes only health
		// (don't write code twice - just reuse it this way)
		this(newHealth);  
		
		// now we add the additional variable setting which is not 
		// covered by the constructor used above
		this.attack = newAttack;
	}
	
}

