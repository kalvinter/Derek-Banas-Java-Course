package lessons;

public class Lesson07 {  // Class name in Lesson is actually Monster
	
	/* AccessModifier Overview:
	 
	            │ Class │ Package │ Subclass │ Subclass │ World
	            │       │         │(same pkg)│(diff pkg)│ 
	────────────┼───────┼─────────┼──────────┼──────────┼────────
	public      │   +   │    +    │    +     │     +    │   +     
	────────────┼───────┼─────────┼──────────┼──────────┼────────
	protected   │   +   │    +    │    +     │     +    │         
	────────────┼───────┼─────────┼──────────┼──────────┼────────
	no modifier │   +   │    +    │    +     │          │    
	────────────┼───────┼─────────┼──────────┼──────────┼────────
	private     │   +   │         │          │          │    
	
	 + : accessible         blank : not accessible
	
	*/
	
	public final String TOMBSTONE = "Here lies a dead monster";
	
	// private variables are not accessible from outside the class
	private int health = 500;
	private int attack = 20;
	private int movement = 2;
	private int xPosition = 0;
	private int yPosition = 0;
	private boolean alive = true;
	
	// public variables are accessible (read, write) from outside the class	
	public String name = "Big Monster";
	
	// protected can only be accessed from inside of the same package 
	// or by a subclass.
	protected String family = "Quark";

	/* Getter -> Methods for accessing private Variables
	 * Setter -> Methods for modifying private Variables
	 * Why getters/setters? Method stays the same for other classes 
	 * while the implementation can be changed without 
	 * having to change the classes using this value
	 * (make some checks, calculation etc. before 
	 *  returning / modifying the variable)
	 */
	public int getAttack() {  
		return attack; 
	}

	public int getMovement() {
		return movement;
	}
	
	public int getHealth() {
		return health;
	}

	public void setHealth(int decreaseHealth) {
		health = health - decreaseHealth;
		
		if (health < 0) {
			alive = false;
		}
	}
	
	/* Overloading: Same method but with different arguments. 
	 * Depending on which values are passed as arguments, the correct
	 * method implementation will be used.
	 * Careful: all definitions in the method except parameters have to be the same
	 * (i.e. name, return-type etc.)
	 * */
	public void setHealth(double decreaseHealth) {
		int decrease = (int) decreaseHealth;
		health = health - decrease;
		
		if (health < 0) {
			alive = false;
		}
	}
	
	// Constructor. No return-type but same name as class
	public Lesson07(int newHealth, int newAttack, int newMovement) {
		// this -> refers to class instance!
		this.health = newHealth;
		this.attack = newAttack;
		this.movement = newMovement;
	}
	
	/* This is the default constructor. It sets no attributes etc.
	 * If any constructor is defined - this default constructor will not
	 * be automatically generated by Java.
	 */
	public Lesson07() {
		
	}
	
	public Lesson07(int newHealth) {
		this.health = newHealth;
	}
	
	public Lesson07(int newHealth, int newAttack) {
		// this calls the appropriate constructor which takes only health
		// (don't write code twice - just reuse it this way)
		this(newHealth);  
		
		// now we add the additional variable setting which is not 
		// covered by the constructor used above
		this.attack = newAttack;
	}
	
}
